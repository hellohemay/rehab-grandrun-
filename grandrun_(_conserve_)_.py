# -*- coding: utf-8 -*-
"""Grandrun ( conserve )  .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L7SB5oQkbGSVF0-0I-utcB_e0VTXEzYB
"""

# -*- coding: utf-8 -*-
"""
使用說明  

📌 診斷 (Diagnosis)
請複製完整診斷 (例如：TBI / SCI / CVA)。
診斷越完整，產生的報告就會越完整。
建議包含關鍵字：dysphagia,aphasia,hemiparesis,hemiplegia,tetraplegia,paraplegia

📌 PE / Functional status / Local finding
請直接貼入復健科完整的 PE，
程式會自動抓取需要的內容。

📌 HTML (治療醫囑)
請到療程整合系統，開啟該病人的復健醫囑畫面。
將各區展開後，使用「Ctrl + Shift + I」複製內文貼入。



import re
from html import unescape

# ============== 基本工具 ==============
def box(selected: bool) -> str:
    return '■' if selected else '□'

def safe_lower(s: str | None) -> str:
    return (s or '').lower()

def one_of(text: str, words: list[str]) -> bool:
    tl = safe_lower(text)
    return any(w in tl for w in words)
def infer_hemi_side_from_local(pe_text: str) -> str | None:
    """
    從 Local finding 或全文找 'left/right hemiplegia/hemiparesis' 等字樣，回傳 'left' / 'right' / None
    """
    t = safe_lower(pe_text or "")

    # 先抓 Local finding 那一行（若有）
    m = re.search(r'local\s*finding\s*:\s*(.+)', t, flags=re.I)
    seg = m.group(1) if m else t  # 沒抓到就用全文降階判讀

    # 右側
    right_pats = [
        r'\bright[^a-z]{0,3}(hemiplegia|hemiparesis)\b',
        r'\brt\.?\b[^.\n]{0,10}(hemiplegia|hemiparesis)\b',
    ]
    for p in right_pats:
        if re.search(p, seg): return 'right'

    # 左側
    left_pats = [
        r'\bleft[^a-z]{0,3}(hemiplegia|hemiparesis)\b',
        r'\blt\.?\b[^.\n]{0,10}(hemiplegia|hemiparesis)\b',
    ]
    for p in left_pats:
        if re.search(p, seg): return 'left'

    return None

# ===== 補齊：共用小工具 =====
def _token_min_value(tok: str | None) -> float:
    """
    把 '4', '4+', '3-4', 'NT' 這類字串轉成用來比較的「最低數值」。
    用於估算 MMT/MP 是否 < 3。
    """
    if not tok:
        return float('inf')
    s = str(tok).strip().upper()
    if s == 'NT':
        return float('inf')
    # 抓出所有 0-5 的數字，取最小
    nums = re.findall(r'[0-5]', s)
    if not nums:
        return float('inf')
    return float(min(int(n) for n in nums))

def build_treatment_block(flags: dict) -> str:
    """
    依 parse_treatments_from_html() + apply_st_from_assessment() 的 flags
    輸出【治療計畫】區塊。
    """
    def line_from(cat: str, items: list[str]) -> str:
        return cat + ": " + " ".join(f"{box(flags.get(cat, {}).get(it, False))}{it}" for it in items)

    pt_items = ['PROM', '傾斜台', '促進', '運動', '轉位', '肌力', '耐力', '行走', '步態', '熱敷', '電療']
    ot_items = ['PROM', '姿態', '肌力', '坐站平衡', '日常生活', '掌指功能', '協調', '上下肢功能', '運動感覺']
    st_items = ['失語症', '吞嚥困難', '構音困難']
    psy_items = ['成人支持', '行為治療計畫', '成人心理生理', '心理測試', '人格特質']
    nurse_items = ['自我照顧能力', '接受衛教能力', '用藥指導', '跌倒危險因子', '身體活動功能']

    lines = ["【治療計畫】"]
    lines.append(line_from('PT', pt_items))
    lines.append(line_from('OT', ot_items))
    lines.append(line_from('ST', st_items))
    lines.append(line_from('PSY', psy_items))
    lines.append(line_from('NURSE', nurse_items))
    return "\n".join(lines)

def build_discharge_goals(goals: dict) -> str:
    """
    把 infer_discharge_goals_from_all() 的結果轉成出院目標區塊。
    """
    order = [
        "自行翻身", "坐姿平衡", "自行轉位", "站立",
        "自行操控輪椅活動", "協助持輔助器行走", "持輔助器獨立行走",
    ]
    lines = ["【出院目標】"]
    lines.append(" ".join(f"{box(bool(goals.get(k)))}{k}" for k in order))
    return "\n".join(lines)



# ============== 版本判定（診斷文字） ==============
def detect_case_type(diagnosis_text: str) -> str:
    d = safe_lower(diagnosis_text)
    if re.search(r'\b(sci|spinal\s*cord\s*injury)\b', d):
        return 'SCI'
    if re.search(r'\b(tbi|traumatic\s*brain\s*injury|head\s*injury)\b', d):
        return 'TBI'
    # 泛用默認 CVA（stroke/ICH/infarct/embolism 等）
    return 'CVA'

# ============== 偏癱側（診斷 / MP / Brunnstrom） ==============
def infer_hemiparesis_side(text: str) -> str | None:
    if not text: return None
    t = text.lower()
    right_patterns = [
        r'\bright(?:[-\s]*sided)?\s*(?:hemi(?:paresis|plegia)|weakness)\b',
        r'(?:hemi(?:paresis|plegia)|weakness)\b[^.\n]*\bright(?:[-\s]*side)?\b',
        r'\brt?\.?\s*(?:hemi(?:paresis|plegia)|weakness)\b',
        r'\br(?:ight)?\s*side\b[^.\n]*\bhemi(?:paresis|plegia)\b',
        r'\brhp\b',
    ]
    left_patterns = [
        r'\bleft(?:[-\s]*sided)?\s*(?:hemi(?:paresis|plegia)|weakness)\b',
        r'(?:hemi(?:paresis|plegia)|weakness)\b[^.\n]*\bleft(?:[-\s]*side)?\b',
        r'\blt?\.?\s*(?:hemi(?:paresis|plegia)|weakness)\b',
        r'\bl(?:eft)?\s*side\b[^.\n]*\bhemi(?:paresis|plegia)\b',
        r'\blhp\b',
    ]
    for p in right_patterns:
        if re.search(p, t): return 'right'
    for p in left_patterns:
        if re.search(p, t): return 'left'
    return None

def _mp_to_float(mp_str: str) -> float:
    mp_str = (mp_str or "").strip()
    m = re.match(r'([0-5])([+-]?)', mp_str)
    if not m: return float('nan')
    base = float(m.group(1)); suf = m.group(2)
    if suf == '+': base += 0.33
    elif suf == '-': base -= 0.33
    return base

def infer_hemiparesis_side_from_mp(pe_text: str) -> str | None:
    if not pe_text: return None
    t = pe_text
    candidates = []
    r1 = re.findall(r'\bR(?:ight)?[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?)', t, flags=re.I)
    l1 = re.findall(r'\bL(?:eft)?[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?)',  t, flags=re.I)
    if r1: candidates.append(('right', _mp_to_float(r1[-1])))
    if l1: candidates.append(('left',  _mp_to_float(l1[-1])))
    r2 = re.findall(r'MP\s*\(\s*R(?:ight)?\s*\)\s*[:：]?\s*([0-5][+-]?)', t, flags=re.I)
    l2 = re.findall(r'MP\s*\(\s*L(?:eft)?\s*\)\s*[:：]?\s*([0-5][+-]?)',  t, flags=re.I)
    if r2: candidates.append(('right', _mp_to_float(r2[-1])))
    if l2: candidates.append(('left',  _mp_to_float(l2[-1])))
    parts = re.findall(r'\b(R|L)(?:UE|LE)\b[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?)', t, flags=re.I)
    if parts:
        r_vals, l_vals = [], []
        for side, mp in parts:
            (r_vals if side.upper()=='R' else l_vals).append(_mp_to_float(mp))
        if r_vals: candidates.append(('right', sum(r_vals)/len(r_vals)))
        if l_vals: candidates.append(('left',  sum(l_vals)/len(l_vals)))
    if not candidates: return None
    r_val = next((v for s, v in candidates if s=='right' and v==v), None)
    l_val = next((v for s, v in candidates if s=='left'  and v==v), None)
    if r_val is not None and l_val is not None:
        if r_val + 0.5 <= l_val: return 'right'
        if l_val + 0.5 <= r_val: return 'left'
    return None

def parse_mp_from_pe(pe_text: str) -> dict:
    t = pe_text or ""
    vals_R, vals_L = [], []
    r_pat = re.findall(r'\bR(?:ight)?[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?)', t, flags=re.I)
    l_pat = re.findall(r'\bL(?:eft)?[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?)',  t, flags=re.I)
    r2 = re.findall(r'MP\s*\(\s*R(?:ight)?\s*\)\s*[:：]?\s*([0-5][+-]?)', t, flags=re.I)
    l2 = re.findall(r'MP\s*\(\s*L(?:eft)?\s*\)\s*[:：]?\s*([0-5][+-]?)',  t, flags=re.I)
    parts = re.findall(r'\b(R|L)(?:UE|LE)\b[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?)', t, flags=re.I)
    vals_R += [_mp_to_float(x) for x in r_pat+r2]
    vals_L += [_mp_to_float(x) for x in l_pat+l2]
    for side, mp in parts:
        (vals_R if side.upper()=='R' else vals_L).append(_mp_to_float(mp))
    def _avg(lst):
        lst = [x for x in lst if x==x]
        return sum(lst)/len(lst) if lst else float('nan')
    R = _avg(vals_R); L = _avg(vals_L)
    if (R==R) and (L==L): ALL = (R+L)/2
    elif (R==R): ALL = R
    elif (L==L): ALL = L
    else: ALL = float('nan')
    return {'R':R,'L':L,'all':ALL}

# ============== 失語/吞嚥/氣切偵測 ==============
def infer_aphasia_types(diag_text: str, pe_text: str) -> tuple[bool, bool]:
    d = safe_lower(diag_text); p = safe_lower(pe_text)
    expr_keys = [r'\bbroca\b', r'\bmotor\b', r'\bexpressive\b', r'\btranscortical\s*motor\b', r'\btcma\b']
    recep_keys = [r'\bwernicke\b', r'\bsensory\b', r'\breceptive\b', r'\btranscortical\s*sensory\b', r'\btcsa\b']
    global_keys = [r'\bglobal\b']
    expr = any(re.search(k, d) for k in expr_keys)
    recep = any(re.search(k, d) for k in recep_keys)
    if any(re.search(k, d) for k in global_keys): expr, recep = True, True
    if not (expr or recep):
        def get_field_val(field: str) -> str | None:
            m = re.search(rf'{field}\s*:\s*([A-Za-z\-]+)', p); return m.group(1).lower() if m else None
        def is_imp(val: str | None) -> bool:
            return bool(val) and any(x in val for x in ['impaired','poor','decreased','abnormal','non-fluent','nonfluent','aphasia'])
        if is_imp(get_field_val('fluency')): expr = True
        if is_imp(get_field_val('comprehension')): recep = True
    if not (expr or recep):
        m = re.search(r'aphasia\s*\(\s*([+-])\s*\)', p)
        if m and m.group(1)=='+': expr = True
    return expr, recep

def infer_speech_swallow_trach(diagnosis_text: str, pe_text: str):
    d = safe_lower(diagnosis_text or "")
    p = safe_lower(pe_text or "")

    # --- 構音 ---
    if re.search(r'dysarthria\s*\(\s*-\s*\)', d+'\n'+p):
        dysarthria = False
    elif re.search(r'dysarthria\s*\(\s*\+\s*\)', d+'\n'+p):
        dysarthria = True
    else:
        # 無 (+/-) 時才把孤立的 dysarthria 視為有
        dysarthria = bool(re.search(r'\bdysarthria\b', d+'\n'+p))

    # --- NG / 氣切（從 Local finding 最末段判）---
    lines = [ln.strip().lower() for ln in (pe_text or "").splitlines() if ln.strip()]
    ng_plus = False
    trach_plus = False
    for ln in reversed(lines):
        if ln.startswith('local finding'):
            if re.search(r'ng[^a-z0-9]*\+', ln):     ng_plus = True
            if re.search(r'(tracheostomy|tr\.)[^a-z0-9]*\+', ln): trach_plus = True
            break
    # 文內另寫 tracheostomy(+) 也算
    trach_plus = trach_plus or bool(re.search(r'\btracheostomy\b.*\(\+\)', d+'\n'+p))

    # --- 吞嚥（只在以下情況才算有）---
    # 1) 診斷文字有 dysphagia（且不是 no/without/(-)）
    dx_has_dysphagia = bool(
        re.search(r'\bdysphagia\b', d) and
        not re.search(r'(no|without)\s+dysphagia|dysphagia\s*\(\s*-\s*\)', d)
    )
    # 2) PE 明寫 (+) 才算；(-) 一律當作沒有；沒有 (+/-) 不當作有
    pe_has_plus = bool(re.search(r'dysphagia\s*\(\s*\+\s*\)', p))
    pe_has_minus = bool(re.search(r'dysphagia\s*\(\s*-\s*\)', p))

    dysphagia_any = False
    if ng_plus:
        dysphagia_any = True
    elif dx_has_dysphagia:
        dysphagia_any = True
    elif pe_has_plus:
        dysphagia_any = True
    elif pe_has_minus:
        dysphagia_any = False
    else:
        dysphagia_any = False  # 沒寫 (+/-) 且診斷沒提 → 不當作有

    return dysarthria, dysphagia_any, trach_plus, ng_plus


# ============== Functional status 解析（移位/移動/行走） ==============
def parse_functional_components(pe_text: str) -> dict:
    """
    拆出各項功能等級：rolling / sit_up / sit_bal / transfer / stand_up / stand_bal / walk
    回傳值皆是 'poor' / 'fair' / 'fair~good' / 'good' / None
    """
    t = safe_lower(pe_text or "")

    def pick_level(pattern: str) -> str | None:
        m = re.search(rf'{pattern}[^.\n]{{0,40}}(poor|fair~good|fair|good)', t)
        return m.group(1) if m else None

    return {
        # 翻身
        'rolling':   pick_level(r'\brolling\b'),
        # 坐起（排除「sitting balance」）
        'sit_up':    pick_level(r'\bsit(?:ting)?(?:\s*up)?\b(?![^.\n]*balance)'),
        # 坐姿平衡
        'sit_bal':   pick_level(r'\bsitting\s*balance\b'),
        # 轉位
        'transfer':  pick_level(r'\btransfer\b'),
        # 站起（排除「standing balance」）
        'stand_up':  pick_level(r'\bstanding(?:\s*up)?\b(?![^.\n]*balance)'),
        # 站立平衡
        'stand_bal': pick_level(r'\bstanding\s*balance\b'),
        # 行走/步態（有些會標 gait/ambulation）
        'walk':      pick_level(r'\b(ambulation|walking|gait|walk)\b'),
    }

def infer_mobility_from_function(pe_text: str) -> str:
    """
    移動方式 (Mobility) 規則：
    - 完全沒提到任何功能/步態 → 回傳空字串（不勾）
    - 若 rolling 與 sit_up 都是 poor → Bed ridden
    - 若 sit_up 為 poor 但 sitting balance 已經 ≥ fair → W/C care
    - 若下列 5 項中（sit_up, transfer, stand_up, sit_bal, stand_bal）至少有「2 項」等級 ≥ fair → W/C activity
    - 若步態/走路資訊顯示可行走：
        * 有寫 walker（walk with/using walker）→ walker
        * 有寫 free ambulation 或 walk independently/without walker → Free ambulation
        * 若僅有 walk/gait 等級 'good' 或 'fair~good' → Free ambulation
        * 若 walk/gait 等級 'poor' → walker
    - 若同時命中「步態可走」與前述條件，步態判讀優先（walker / Free ambulation 會覆蓋前面的 W/C*）
    """
    comp = parse_functional_components(pe_text)
    has_any = any(comp.values()) or bool(re.search(r'\b(ambulation|walking|gait|walk)\b', safe_lower(pe_text or "")))
    if not has_any:
        return ""  # 完全沒資訊 → 空白

    # 1) 最重：翻身+坐起都 poor → Bed ridden
    if (comp.get('rolling') == 'poor') and (comp.get('sit_up') == 'poor'):
        mobility = 'Bed ridden'
    else:
        # 2) 坐起 poor 但坐姿平衡 >= fair → W/C care
        if comp.get('sit_up') == 'poor' and comp.get('sit_bal') in ('fair', 'fair~good', 'good'):
            mobility = 'W/C care'
        else:
            # 3) 在下列 5 項中，至少 2 項達到 >= fair → W/C activity
            bucket = [comp.get('sit_up'), comp.get('transfer'), comp.get('stand_up'), comp.get('sit_bal'), comp.get('stand_bal')]
            at_least_fair = sum(1 for x in bucket if x in ('fair', 'fair~good', 'good'))
            mobility = 'W/C activity' if at_least_fair >= 2 else 'W/C care'

    # 4) 依步態/走路覆蓋
    txt = safe_lower(pe_text or "")
    # 4a) 文字判讀（自由行走 / 需要助行器）
    free_patterns = [
        r'\bfree\s*ambulation\b',
        r'\bwalk(?:ing)?\s+(independent|independently)\b',
        r'\bwalk(?:ing)?\s+without\s+(a\s*)?(walker|aid|assistive\s*device)\b',
    ]
    walker_patterns = [
        r'\bwalk(?:ing)?\s+(with|using)\s+(a\s*)?walker\b',
        r'\bwalker\b',
    ]
    if any(re.search(p, txt) for p in walker_patterns):
        return 'walker'
    if any(re.search(p, txt) for p in free_patterns):
        return 'Free ambulation'

    # 4b) 以 walk/gait 的等級推論
    walk_level = comp.get('walk')
    if walk_level in ('good', 'fair~good'):
        return 'Free ambulation'
    if walk_level == 'poor':
        return 'walker'

    return mobility

def infer_transfer_from_function(pe_text: str) -> str:
    """
    轉位能力：直接讀 functional status 的 transfer 等級。
    沒寫就回傳空字串（不勾）。
    """
    level = parse_functional_components(pe_text).get('transfer')
    if level == 'good': return 'Good'
    if level == 'fair~good': return 'Fair~good'
    if level == 'fair': return 'Fair'
    if level == 'poor': return 'Poor'
    return ""


# ============== Brunnstrom / MAS ==============
def parse_brunnstrom_block(pe_text: str) -> tuple[str, str, str, str]:
    pe = pe_text or ''
    mL = re.search(r'left\s*limbs\s*:\s*([IVXivx\-\s/]+)', pe, re.I)
    mR = re.search(r'right\s*limbs\s*:\s*([IVXivx\-\s/]+)', pe, re.I)
    side, parts = 'Right', None
    if mR: side, parts = 'Right', mR.group(1)
    if mL: side, parts = 'Left',  mL.group(1)
    up = ud = ll = 'NA'
    if parts:
        seg = [x.strip() for x in parts.split('/') if x.strip()]
        if len(seg) == 3: up, ud, ll = seg
    return side, up, ud, ll

def default_mas():
    return ('0/0/0', '0/0', '0/0/0', '0/0')

# ============== 認知障礙（以 Comprehension 為主） ==============
def infer_cognition_level(pe_text: str) -> str:
    p = safe_lower(pe_text or "")
    if re.search(r'comprehension\s*:\s*(impaired|poor|decreased|abnormal)', p):
        return '差'
    if re.search(r'comprehension\s*:\s*(fair|fair~good)', p):
        return '尚可'
    if re.search(r'cognition[^:\n]*\b(poor|impaired|decreased|abnormal)\b', p):
        return '差'
    if re.search(r'cognition[^:\n]*\bfair\b', p):
        return '尚可'
    return '良'

# ============== Local finding 管路（NG/Foley/Tr.） ==============
def parse_local_finding_tubes(pe_text: str) -> tuple[bool,bool,bool]:
    lines = [ln.strip().lower() for ln in (pe_text or "").splitlines() if ln.strip()]
    ng = foley = tr = False
    for ln in reversed(lines):
        if ln.startswith('local finding'):
            if re.search(r'ng[^a-z0-9]*\+', ln):     ng = True
            if re.search(r'foley[^a-z0-9]*\+', ln):  foley = True
            if re.search(r'(tracheostomy|tr\.)[^a-z0-9]*\+', ln): tr = True
            break
    return ng, foley, tr

# ============== ST 自動覆蓋（由臨床評估） ==============
def apply_st_from_assessment(flags: dict, diagnosis_text: str, pe_text: str) -> dict:
    expr, recep = infer_aphasia_types(diagnosis_text, pe_text)
    dysarthria, dysphagia_any, _, _ = infer_speech_swallow_trach(diagnosis_text, pe_text)
    has_aphasia = bool(expr or recep)
    flags.setdefault('ST', {'失語症': False, '吞嚥困難': False, '構音困難': False})
    flags['ST']['失語症']   = has_aphasia
    flags['ST']['吞嚥困難'] = dysphagia_any
    flags['ST']['構音困難'] = bool(dysarthria)
    return flags


# ============== 解析 HTML → 治療計畫（護理全勾；不自動勾 PT運動/肌力/OT上下肢功能/肌力） ==============
def parse_treatments_from_html(html_text: str) -> dict:
    txt = unescape(re.sub(r'\s+', ' ', html_text or "")).lower()

    def has(*keys):
        return any(k.lower() in txt for k in keys)

    result = {
        'PT': {'PROM': False, '傾斜台': False, '促進': False, '運動': False, '轉位': False, '肌力': False,
               '耐力': False, '行走': False, '步態': False, '熱敷': False, '電療': False},
        'OT': {'PROM': False, '姿態': False, '肌力': False, '坐站平衡': False, '日常生活': False,
               '掌指功能': False, '協調': False, '上下肢功能': False, '運動感覺': False},
        'ST': {'失語症': False, '吞嚥困難': False, '構音困難': False},
        'PSY': {'成人支持': False, '行為治療計畫': False, '成人心理生理': False, '心理測試': False, '人格特質': False},
        'NURSE': {'自我照顧能力': True, '接受衛教能力': True, '用藥指導': True, '跌倒危險因子': True, '身體活動功能': True}
    }

    # ---------- PT 對應 ----------
    # PROM
    if has('ptm5', 'passive r.o.m', 'passive rom', '被動性關節運動'):
        result['PT']['PROM'] = True
    # 傾斜台
    if has('ptm8', 'tilting table'):
        result['PT']['傾斜台'] = True
    # 促進（神經促進技巧）
    if has('ptc1', 'facilitation techniques', '促進技術', '姿勢訓練', 'posture training', 'ptm13'):
        result['PT']['促進'] = True
    # 運動（一般治療性運動/伸展）
    if has('ptm7', 'therapeutic ex', 'ptm6', 'stretching'):
        result['PT']['運動'] = True
    # 轉位（PT 清單沒有明確 transfer 項；不自動勾）
    # 肌力
    if has('ptm9', 'strengthening'):
        result['PT']['肌力'] = True
    # 耐力
    if has('ptm10', 'endurance'):
        result['PT']['耐力'] = True
    # 行走 / 步態
    if has('ptc6', 'ambulation training', '行走訓練'):
        result['PT']['行走'] = True
        result['PT']['步態'] = True
    # 熱敷（含 hot/cold pack、paraffin 等熱療）
    if has('pts2', 'hot\\cold pack', 'hot cold pack', '熱敷') or has('pts4', 'paraffin'):
        result['PT']['熱敷'] = True
    # 電療（tens／干擾波／肌電刺激／雷射等皆算）
    if has('pts8', 'interferential') or has('pts9', 'tens') or has('ptm1', 'muscle stimulation') \
       or has('pts11', 'low power laser') or has('pts10', 'high frequency discharge'):
        result['PT']['電療'] = True
    # 其餘物理因子治療（超音波、短波、微波…）不影響上述 11 個欄位，就不額外對映

    # ---------- OT 對應 ----------
    # PROM
    if has('ot2', '被動性關節訓練', 'passive'):
        result['OT']['PROM'] = True
    # 姿態
    if has('ot1', 'posture training', '姿態訓練'):
        result['OT']['姿態'] = True
    # 肌力
    if has('ot6', 'muscle strenght', 'muscle strength'):
        result['OT']['肌力'] = True
    # 坐站平衡
    if has('ot3', '坐站平衡', 'sitting balance'):
        result['OT']['坐站平衡'] = True
    # 日常生活
    if has('ot5', 'adl training', '日常生活'):
        result['OT']['日常生活'] = True
    # 掌指功能
    if has('ot10', 'hand on foot function', '掌指功能'):
        result['OT']['掌指功能'] = True
    # 協調
    if has('ot11', 'coordination', '協調訓練'):
        result['OT']['協調'] = True
    # 上下肢功能
    if has('ot8', 'u/e or l/e function training', '上肢(下肢)功能訓練', '上下肢功能'):
        result['OT']['上下肢功能'] = True
    # 運動感覺（感覺統合/運動知覺）
    if has('ot7', 'motion sensory', '運動知覺', 'sensory'):
        result['OT']['運動感覺'] = True

    # ---------- ST/PSY：保留你原本規則 ----------
    if '吞嚥' in txt or 'oral tx' in txt: result['ST']['吞嚥困難'] = True
    if '構音' in txt or 'dysarthria' in txt: result['ST']['構音困難'] = True
    if any(k in txt for k in ['語言治療', 'auditory comprehension', 'verbal production']): result['ST']['失語症'] = True

    if '行為治療計畫' in txt: result['PSY']['行為治療計畫'] = True
    if any(k in txt for k in ['心理測檢', '心理測試', '電腦化神經心理測驗']): result['PSY']['心理測試'] = True
    if '人格特質' in txt: result['PSY']['人格特質'] = True
    if any(k in txt for k in ['生理心理功能', '成人']):
        result['PSY']['成人心理生理'] = True
        result['PSY']['成人支持'] = True

    return result


# ============== Barthel Index 區塊擷取（原文帶出） ==============
def extract_barthel_block(pe_text: str) -> str | None:
    if not pe_text: return None
    lines = pe_text.splitlines()
    start_idx = None
    for i, ln in enumerate(lines):
        if re.search(r'^\s*barthel\s*index\s*$', ln, flags=re.I) or re.search(r'^\s*barthel\s*index\b', ln, flags=re.I):
            start_idx = i
            break
    if start_idx is None:
        # 也支援全大寫 BARTHEL INDEX
        for i, ln in enumerate(lines):
            if re.search(r'^\s*BARTHEL\s*INDEX\s*$', ln):
                start_idx = i
                break
    if start_idx is None:
        return None
    # 往下收集到空行／分隔線／下一個大段標題
    buff = []
    for ln in lines[start_idx:]:
        if not ln.strip():
            if buff: break
        if re.match(r'={3,}', ln): break
        if re.match(r'^\s*(Local finding|Functional status|COORDINATION|OTHER NEUROLOGICAL|SENSORY FUNCTION)\b', ln, flags=re.I):
            break
        buff.append(ln.rstrip())
    return '\n'.join(buff).strip() if buff else None

# ============== SCI 專用：從 MP 表格估 MMT（RUL/RLL/LUL/LLL） ==============
def _pick_min_score_token(tokens: list[str]) -> str | None:
    """在多個 '0-5(+/-)'、'3-4'、'NT' 標記中，回傳**最低**那一個（保留原字串）。"""
    def tok_min_val(tok: str) -> float:
        if not tok: return float('inf')
        t = tok.strip().upper()
        if t == 'NT': return float('inf')
        # '3-4' 取 3；'4-'、'3+' 都以數字本體計算
        nums = re.findall(r'[0-5]', t)
        return min(float(n) for n in nums) if nums else float('inf')
    if not tokens: return None
    return sorted(tokens, key=tok_min_val)[0]

def parse_mmt_ul_ll_from_pe(pe_text: str) -> dict:
    """
    優先解析 M.P.(0-5) 表（proximal/distal）；若沒有，改抓 ASIA motor table（C5~T1、L2~S1）。
    規則：**proximal 優先**、若多筆取**最低**；proximal 缺才用 distal。
      RUL/LUL ← 上肢（prox: C5、C7；dist: C6、C8、T1）
      RLL/LLL ← 下肢（prox: L2、L3；dist: L4、L5、S1）
    找不到回傳 'NA'
    """
    RUL = RLL = LUL = LLL = 'NA'
    if not pe_text:
        return {'RUL':RUL,'RLL':RLL,'LUL':LUL,'LLL':LLL}

    text = pe_text

    # ---------- A) 先嘗試 M.P.(0-5) 表 ----------
    m = re.search(r'M\.?P\.?\s*:\s*\(0-5\)(.*?)\n={3,}', text, flags=re.I|re.S)
    block = m.group(1) if m else None

    def collect_mp_tokens(src: str, limb: str, part: str, side: str) -> list[str]:
        toks = []
        pat = rf'{limb}\s+{part}\s+([0-5][+-]?|NT)\s+([0-5][+-]?|NT)'
        for mm in re.finditer(pat, src, flags=re.I):
            toks.append(mm.group(1 if side == 'R' else 2))
        return toks

    if block:
        r_ul = _pick_min_score_token(collect_mp_tokens(block, 'upper', 'proximal', 'R')) or \
               _pick_min_score_token(collect_mp_tokens(block, 'upper', 'distal',   'R'))
        l_ul = _pick_min_score_token(collect_mp_tokens(block, 'upper', 'proximal', 'L')) or \
               _pick_min_score_token(collect_mp_tokens(block, 'upper', 'distal',   'L'))
        r_ll = _pick_min_score_token(collect_mp_tokens(block, 'lower', 'proximal', 'R')) or \
               _pick_min_score_token(collect_mp_tokens(block, 'lower', 'distal',   'R'))
        l_ll = _pick_min_score_token(collect_mp_tokens(block, 'lower', 'proximal', 'L')) or \
               _pick_min_score_token(collect_mp_tokens(block, 'lower', 'distal',   'L'))

        if r_ul: RUL = r_ul
        if l_ul: LUL = l_ul
        if r_ll: RLL = r_ll
        if l_ll: LLL = l_ll
        return {'RUL':RUL,'RLL':RLL,'LUL':LUL,'LLL':LLL}

    # ---------- B) 沒有 MP 表 → 解析 ASIA motor table ----------
    # 典型格式：
    # Right               Left
    #   3-4  C5(...)      3-4
    #   2    C6(...)      2
    #   ...
    asia = {'R':{}, 'L':{}}

    def grab_row(level: str) -> tuple[str|None, str|None]:
        # 右值在左，左值在右
        pat = rf'^\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])\s*{level}\b.*?([0-5][+-]?|[0-5]\s*-\s*[0-5])\s*$'
        m1 = re.search(pat, text, flags=re.I|re.M)
        if m1: return m1.group(1).strip(), m1.group(2).strip()
        # 某些檔案可能把左/右顛倒或同列多空白，做再一種寬鬆版
        pat2 = rf'{level}\b.*?([0-5][+-]?|[0-5]\s*-\s*[0-5]).*?([0-5][+-]?|[0-5]\s*-\s*[0-5])'
        m2 = re.search(pat2, text, flags=re.I|re.S)
        if m2: return m2.group(1).strip(), m2.group(2).strip()
        return None, None

    for lv in ['C5','C6','C7','C8','T1','L2','L3','L4','L5','S1']:
        r, l = grab_row(lv)
        if r: asia['R'][lv] = r
        if l: asia['L'][lv] = l

    # 上肢：prox（C5、C7）；dist（C6、C8、T1）
    r_ul = _pick_min_score_token([asia['R'].get(x) for x in ['C5','C7'] if asia['R'].get(x)]) or \
           _pick_min_score_token([asia['R'].get(x) for x in ['C6','C8','T1'] if asia['R'].get(x)])
    l_ul = _pick_min_score_token([asia['L'].get(x) for x in ['C5','C7'] if asia['L'].get(x)]) or \
           _pick_min_score_token([asia['L'].get(x) for x in ['C6','C8','T1'] if asia['L'].get(x)])
    # 下肢：prox（L2、L3）；dist（L4、L5、S1）
    r_ll = _pick_min_score_token([asia['R'].get(x) for x in ['L2','L3'] if asia['R'].get(x)]) or \
           _pick_min_score_token([asia['R'].get(x) for x in ['L4','L5','S1'] if asia['R'].get(x)])
    l_ll = _pick_min_score_token([asia['L'].get(x) for x in ['L2','L3'] if asia['L'].get(x)]) or \
           _pick_min_score_token([asia['L'].get(x) for x in ['L4','L5','S1'] if asia['L'].get(x)])

    if r_ul: RUL = r_ul
    if l_ul: LUL = l_ul
    if r_ll: RLL = r_ll
    if l_ll: LLL = l_ll
    return {'RUL':RUL,'RLL':RLL,'LUL':LUL,'LLL':LLL}
def parse_mp_from_pe(pe_text: str) -> dict:
    """
    先嘗試從 MP 表抓 R/L 的多筆 MP 值；若沒有，就從 ASIA motor table（C5~T1、L2~S1）抓。
    回傳 {'R': 平均數值, 'L': 平均數值, 'all': 兩側平均}；抓不到回傳 NaN。
    """
    t = pe_text or ""
    vals_R, vals_L = [], []

    def _mp_to_float(mp_str: str) -> float:
        if not mp_str: return float('nan')
        s = mp_str.strip().upper()
        if s == 'NT': return float('nan')
        # '3-4' → 取 (3+4)/2? 這裡我們要「保守」，用較低：3
        nums = re.findall(r'[0-5]', s)
        if not nums: return float('nan')
        return float(min(int(n) for n in nums))

    # A) 先找 MP 表
    r_pat = re.findall(r'\bR(?:ight)?[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])', t, flags=re.I)
    l_pat = re.findall(r'\bL(?:eft)?[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])',  t, flags=re.I)
    r2 = re.findall(r'MP\s*\(\s*R(?:ight)?\s*\)\s*[:：]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])', t, flags=re.I)
    l2 = re.findall(r'MP\s*\(\s*L(?:eft)?\s*\)\s*[:：]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])',  t, flags=re.I)
    parts = re.findall(r'\b(R|L)(?:UE|LE)\b[^:\n]{0,20}MP\s*[:：]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])', t, flags=re.I)

    vals_R += [_mp_to_float(x) for x in r_pat+r2]
    vals_L += [_mp_to_float(x) for x in l_pat+l2]
    for side, mp in parts:
        (vals_R if side.upper()=='R' else vals_L).append(_mp_to_float(mp))

    # B) 若 MP 表沒抓到，改抓 ASIA motor table
    if not vals_R and not vals_L:
        def pick(level: str) -> tuple[list[float], list[float]]:
            # 同一層級只會有一列，抓兩側
            pat = rf'^\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])\s*{level}\b.*?([0-5][+-]?|[0-5]\s*-\s*[0-5])\s*$'
            m = re.search(pat, t, flags=re.I|re.M)
            if not m:
                pat2 = rf'{level}\b.*?([0-5][+-]?|[0-5]\s*-\s*[0-5]).*?([0-5][+-]?|[0-5]\s*-\s*[0-5])'
                m = re.search(pat2, t, flags=re.I|re.S)
            if not m: return [], []
            return [_mp_to_float(m.group(1))], [_mp_to_float(m.group(2))]
        for lv in ['C5','C6','C7','C8','T1','L2','L3','L4','L5','S1']:
            r, l = pick(lv)
            vals_R += r
            vals_L += l

    def avg(lst):
        lst = [x for x in lst if x == x]  # drop NaN
        return sum(lst)/len(lst) if lst else float('nan')

    R = avg(vals_R)
    L = avg(vals_L)
    if (R==R) and (L==L): ALL = (R+L)/2
    elif (R==R): ALL = R
    elif (L==L): ALL = L
    else: ALL = float('nan')
    return {'R': R, 'L': L, 'all': ALL}



# ============== 出院目標  ==============

def infer_discharge_goals_from_all(pe_text: str, ll_token: str | None) -> dict:
    """
    規則（適用 CVA/SCI/TBI 全部）：
    1) 若 Functional status 的 transfer、sit up **都 Poor**（或四大項皆 Poor）；
       **或** 任一 MMT/MP < 3  → 勾「自行轉位」「坐姿平衡」
    2) Gait/Walker：
       - 明確寫可**不需 walker** 行走 → 勾「持輔助器獨立行走」
       - 明確寫**需要 walker** 行走 → 勾「協助持輔助器行走」
    3) 若 Stand up 達 **Fair 以上** → 勾「自行操控輪椅活動」
    4) Brunnstrom 下肢（LL）若含 V 或 VI → 再加強「持輔助器獨立行走」
    """
    goals = {
        "自行翻身": False, "坐姿平衡": False, "自行轉位": False, "站立": False,
        "自行操控輪椅活動": False, "協助持輔助器行走": False, "持輔助器獨立行走": False,
    }

    txt = (pe_text or "").lower()
    comp = parse_functional_components(pe_text)

    # --- (1) 轉位/坐姿平衡條件 ---
    four = [comp.get('rolling'), comp.get('sit_up'), comp.get('transfer'), comp.get('stand_up')]
    all_poor = all(v == 'poor' for v in four if v is not None) and len([v for v in four if v is not None]) >= 2

    # MP/MT (MMT) < 3 ?
    mp_all = parse_mp_from_pe(pe_text).get('all', float('inf'))
    mmt = parse_mmt_ul_ll_from_pe(pe_text)
    mmt_min = min(_token_min_value(mmt[k]) for k in ['RUL','RLL','LUL','LLL'] if k in mmt)

    if all_poor or (mp_all < 3) or (mmt_min < 3):
        goals["坐姿平衡"] = True
        goals["自行轉位"] = True

    # 若 rolling 也是 poor，附帶把「自行翻身」一併拉進目標（常見早期目標）
    if comp.get('rolling') == 'poor':
        goals["自行翻身"] = True

    # --- (2) Gait / Walker 判讀 ---
    # 不需 walker（獨立行走）
    if re.search(r'\bfree\s*ambulation\b', txt) or \
       re.search(r'\bwalk(?:ing)?\s+(independent|independently|without\s+(a\s*)?(walker|aid|assistive\s*device))\b', txt):
        goals["持輔助器獨立行走"] = True
    # 需要 walker（協助持輔具行走）
    if re.search(r'\bwalk(?:ing)?\s+(with|using)\s+(a\s*)?walker\b', txt) or \
       re.search(r'\bwalker\b', txt) and not goals["持輔助器獨立行走"]:
        goals["協助持輔助器行走"] = True

    # --- (3) 站立到 Fair 以上 → 輪椅活動（自操控） ---
    if comp.get('stand_up') in ('fair', 'fair~good', 'good'):
        goals["自行操控輪椅活動"] = True
        goals["站立"] = True

    # --- (4) Brunnstrom LL V/VI → 獨立持輔具行走 ---
    if ll_token:
        s = ll_token.upper().replace(' ', '')
        if any(p in ['V','VI'] for p in re.split(r'[-/]', s)):
            goals["持輔助器獨立行走"] = True

    return goals
# ===== 補齊：出院目標區塊的輸出 =====
def build_discharge_goals(goals: dict) -> str:
    """把 infer_discharge_goals_from_all 回傳的布林 dict 排版成區塊文字。"""
    def b(x): return '■' if x else '□'
    order = ["自行翻身", "坐姿平衡", "自行轉位", "站立", "自行操控輪椅活動", "協助持輔助器行走", "持輔助器獨立行走"]
    line = " ".join(f"{b(goals.get(k, False))}{k}" for k in order)
    return "【出院目標】\n" + line

# ============== 計畫修正與加強（沿用你的規則） ==============
def build_plan_adjustment_from_assessment(diag: str, pe: str) -> str:
    expr, recep = infer_aphasia_types(diag, pe)
    is_global = expr and recep
    dysarthria, dysphagia_any, _, _ = infer_speech_swallow_trach(diag, pe)

    # ST 勾選
    st = {'口腔動作訓練': False,'發音': False,'吞嚥能力': False,'語言理解': False,'語言表達': False,'口語長度': False}
    if dysphagia_any: st['口腔動作訓練'] = st['吞嚥能力'] = True
    if expr or recep or is_global: st['發音'] = st['口語長度'] = True
    if is_global:
        st['語言表達'] = True; st['語言理解'] = True
    else:
        if expr:  st['語言表達'] = True
        if recep: st['語言理解'] = True

    # 護理（管路：看 Local finding）
    ng, foley, tr = parse_local_finding_tubes(pe)
    nursing_tube = (ng or foley or tr)
    tube_str = f"（{ '■NG' if ng else '□NG' } { '■Foley' if foley else '□Foley' } { '■Tr.' if tr else '□Tr.' }）"

    ptot = "PT&OT: " + " ".join([
        f"{box(False)}PROM", f"{box(True)}移位訓練", f"{box(True)}坐姿平衡", f"{box(True)}肌力",
        f"{box(True)}站立平衡", f"{box(True)}掌指功能", f"{box(True)}步態", f"{box(False)}耐力",
        f"{box(True)}日常生活", f"{box(True)}協調", f"{box(False)}認知功能", f"{box(False)}電療", f"{box(False)}其他:____",
    ])
    st_line = "ST: " + " ".join([
        f"{box(st['口腔動作訓練'])}口腔動作訓練",
        f"{box(st['發音'])}發音",
        f"{box(st['吞嚥能力'])}吞嚥能力",
        f"{box(st['語言理解'])}語言理解",
        f"{box(st['語言表達'])}語言表達",
        f"{box(st['口語長度'])}口語長度",
    ])
    psy_line = "Psy: " + " ".join([
        f"{box(True)}認知功能", f"{box(True)}注意力", f"{box(False)}記憶力",
        f"{box(False)}執行功能", f"{box(False)}情緒控制", f"{box(True)}家屬諮詢", f"{box(True)}疾病適應",
    ])
    nurse_line = "護理: " + " ".join([
        f"{box(True)}自我照顧能力",
        f"{box(nursing_tube)}管路照顧與移除{tube_str}",
        f"{box(True)}跌倒預防",
        f"{box(False)}皮膚/傷口照顧",
        f"{box(False)}感染預防",
        f"{box(False)}安置",
    ])
    return "【治療計畫修正與加強】\n" + "\n".join([ptot, st_line, psy_line, nurse_line, "家屬:", "全人:"])

# ============== 臨床評估（依版本切換差異行） ==============
def build_clinical_assessment_block(diagnosis_text: str, pe_text: str) -> str:
    case_type = detect_case_type(diagnosis_text)

    # 側別（優先序：MP > 診斷 > Brunnstrom 主詞 > 右）— CVA 仍用於左/右無力打勾
    side_mp = infer_hemiparesis_side_from_mp(pe_text)
    side_diag = infer_hemiparesis_side(diagnosis_text)
    side_pe, up, ud, ll = parse_brunnstrom_block(pe_text)
    side = (side_mp or side_diag or (side_pe.lower() if side_pe else None) or 'right')

    # 語言/吞嚥/管路
    expr, recep = infer_aphasia_types(diagnosis_text, pe_text)
    dysarthria, dysphagia_any, trach_plus, ng_plus = infer_speech_swallow_trach(diagnosis_text, pe_text)

    # 移動方式 / 移位能力 / 認知
    mobility = infer_mobility_from_function(pe_text)
    transfer_ability = infer_transfer_from_function(pe_text)
    cog_level = infer_cognition_level(pe_text)

    # MAS 預設
    mas_R_el_wri_fin, mas_R_knee_ank, mas_L_el_wri_fin, mas_L_knee_ank = default_mas()

    # 吞嚥障礙：NG(+)→嚴重；否則若有 dysphagia → 輕度；否則無（只勾一個）
    swallow_none = swallow_mild = swallow_severe = False
    if ng_plus: swallow_severe = True
    elif dysphagia_any: swallow_mild = True
    else: swallow_none = True

    # 語言障礙
    is_global = expr and recep

    lines = []
    lines.append('【臨床評估】')
    # ======= 肢體無力類型（依「診斷」決定：四肢/雙下肢/單側）＋ 側別（優先序：MP > Local finding > 診斷 > Brunnstrom > 預設右） =======
    diag_low = safe_lower(diagnosis_text)
    has_quadri = any(w in diag_low for w in ["tetraplegia", "quadriplegia"])
    has_para  = "paraplegia" in diag_low
    has_hemi  = any(w in diag_low for w in ["hemiplegia", "hemiparesis"])

    # 側別優先序：MP > Local finding > diagnosis > Brunnstrom > 預設右
    side_mp     = infer_hemiparesis_side_from_mp(pe_text)
    side_local  = infer_hemi_side_from_local(pe_text)
    side_diag   = infer_hemiparesis_side(diagnosis_text)
    side_pe, up, ud, ll = parse_brunnstrom_block(pe_text)
    side = (side_mp or side_local or side_diag or (side_pe.lower() if side_pe else None) or 'right')

    if has_quadri:
        limb_text = f"{box(False)}肢體偏癱 {box(False)}雙下肢無力 {box(True)}四肢無力 {box(False)}左側無力 {box(False)}右側無力"
    elif has_para:
        limb_text = f"{box(False)}肢體偏癱 {box(True)}雙下肢無力 {box(False)}四肢無力 {box(False)}左側無力 {box(False)}右側無力"
    elif has_hemi:
        limb_text = f"{box(True)}肢體偏癱 {box(False)}雙下肢無力 {box(False)}四肢無力 {box(side=='left')}左側無力 {box(side=='right')}右側無力"
    else:
        # 若診斷沒有明確三類關鍵字，fallback 維持原本顯示邏輯（以推論側別顯示單側）
        limb_text = f"{box(True)}肢體偏癱 {box(False)}雙下肢無力 {box(False)}四肢無力 {box(side=='left')}左側無力 {box(side=='right')}右側無力"

    lines.append(limb_text)

    lines.append('移動方式 ' + ' '.join([
        f"{box(mobility=='Bed ridden')}Bed ridden",
        f"{box(mobility=='W/C care')}W/C care",
        f"{box(mobility=='W/C activity')}W/C activity",
        f"{box(mobility=='walker')}walker",
        f"{box(mobility=='Free ambulation')}Free ambulation",
    ]))
    lines.append('移位能力 ' + ' '.join([
        f"{box(transfer_ability=='Good')}Good",
        f"{box(transfer_ability=='Fair~good')}Fair~good",
        f"{box(transfer_ability=='Fair')}Fair",
        f"{box(transfer_ability=='Poor~fair')}Poor~fair",
        f"{box(transfer_ability=='Poor')}Poor",
    ]))

    # 版本差異行：
    if case_type == 'CVA':
        side_cap = 'Right' if str(side).startswith('r') else 'Left'
        lines.append(f'Brunnstrom stage: {side_cap}   up / ud / ll: {up} / {ud} / {ll}')
    elif case_type == 'SCI':
        mmt = parse_mmt_ul_ll_from_pe(pe_text)
        lines.append(f"MMT: RUL/RLL: {mmt['RUL']} / {mmt['RLL']}   LUL/LLL: {mmt['LUL']} / {mmt['LLL']}")
        barthel = extract_barthel_block(pe_text)
        if barthel:
            lines.append(barthel)
    elif case_type == 'TBI':
        barthel = extract_barthel_block(pe_text)
        if barthel:
            lines.append(barthel)

    # 其餘相同
    lines.append('痙攣spasticity: Right (elbow/wrist/finger, knee/ankle):' f'{mas_R_el_wri_fin},{mas_R_knee_ank}')
    lines.append('              (MAS)Left (elbow/wrist/finger, knee/ankle):' f'{mas_L_el_wri_fin},{mas_L_knee_ank}')
    lines.append("吞嚥障礙 " + ' '.join([
        f"{box(swallow_none)}無",
        f"{box(swallow_mild)}輕度、需監視",
        f"{box(swallow_severe)}嚴重、需鼻胃管",
    ]))
    lines.append("語言障礙 " + ' '.join([
        f"{box(not (expr or recep or dysarthria or trach_plus))}無",
        f"{box(expr and not is_global)}表達性失語症",
        f"{box(recep and not is_global)}接受性失語症",
        f"{box(is_global)}球性失語症",
        f"{box(dysarthria)}構音異常",
        f"{box(trach_plus)}氣切",
    ]))
    lines.append(f"認知障礙 {box(cog_level=='差')}差 {box(cog_level=='尚可')}尚可 {box(cog_level=='良')}良")
    lines.append(f"關節攣縮 {box(True)}無 {box(False)}有、部位________________")
    return '\n'.join(lines)

# ============== 出院目標區塊 & 報告封裝 ==============
def build_discharge_goals_block(pe_text: str) -> str:
    _, _, _, ll = parse_brunnstrom_block(pe_text)
    goals = infer_discharge_goals_from_all(pe_text, ll)
    return build_discharge_goals(goals)

def generate_report(diagnosis_text: str, pe_text: str, html_text: str) -> str:
    assessment = build_clinical_assessment_block(diagnosis_text, pe_text)
    flags = parse_treatments_from_html(html_text)
    flags = apply_st_from_assessment(flags, diagnosis_text, pe_text)
    treatment = build_treatment_block(flags)
    goals = build_discharge_goals_block(pe_text)
    adjust = build_plan_adjustment_from_assessment(diagnosis_text, pe_text)
    return "\n\n".join([assessment, treatment, goals, adjust])


import streamlit as st

st.title("🏥 復健科 Grandrun 報告產生器")

diagnosis_text = st.text_area("診斷 (Diagnosis)", height=150)
pe_text = st.text_area("PE / Functional status / Local finding", height=300)
html_text = st.text_area("HTML (治療醫囑)", height=200)

if st.button("產生報告"):
    if not diagnosis_text.strip() and not pe_text.strip():
        st.warning("請至少輸入 Diagnosis 或 PE")
    else:
        report = generate_report(diagnosis_text, pe_text, html_text)
        st.success("✅ 已產生報告")
        st.text_area("報告內容", report, height=600)
